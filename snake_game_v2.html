<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>贪吃蛇 2.0（iPad 全屏版）</title>
  <style>
    :root{
      --bg:#0b0f19;
      --border: rgba(255,255,255,.14);
      --text:#e8eefc;
      --muted: rgba(232,238,252,.72);
      --shadow: 0 14px 36px rgba(0,0,0,.40);
      --panel: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    }
    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      margin:0;
      background: radial-gradient(1100px 800px at 30% 10%, #1a2346 0%, var(--bg) 55%, #070a12 100%);
      color:var(--text);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;
      overflow:hidden;
    }

    /* Fullscreen layout */
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding:
        calc(12px + env(safe-area-inset-top))
        calc(12px + env(safe-area-inset-right))
        calc(12px + env(safe-area-inset-bottom))
        calc(12px + env(safe-area-inset-left));
      gap: 10px;
    }

    header{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: var(--panel);
      box-shadow: var(--shadow);
      flex: 0 0 auto;
    }
    h1{ margin:0; font-size:14px; font-weight: 1000; letter-spacing:.2px; }
    .sub{ font-size:12px; color: var(--muted); text-align:right; line-height:1.35; }

    .main{
      flex: 1 1 auto;
      display:flex;
      min-height: 0;
      gap: 10px;
    }

    /* Left: game canvas (dominant) */
    .arena{
      flex: 1 1 auto;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.16);
      overflow:hidden;
      box-shadow: var(--shadow);
      min-width: 0;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }
    canvas{
      width: 100%;
      height: 100%;
      display:block;
      touch-action:none;
    }

    /* Right: controls (compact but readable on iPad) */
    .panel{
      flex: 0 0 320px;
      max-width: 360px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap: 12px;
      min-height: 0;
    }

    .row{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pill{
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.16);
      color: rgba(232,238,252,.90);
      font-weight: 900;
      font-size: 12px;
      display:inline-flex;
      gap: 8px;
      align-items:center;
      white-space:nowrap;
    }

    button{
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(18,26,43,.55);
      color: var(--text);
      font-weight: 1000;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      flex: 1 1 auto;
      min-width: 120px;
    }
    button.primary{
      border-color: rgba(110,168,255,.46);
      background: linear-gradient(180deg, rgba(110,168,255,.34), rgba(110,168,255,.12));
    }
    button.warn{
      border-color: rgba(255,230,120,.30);
      background: linear-gradient(180deg, rgba(255,230,120,.22), rgba(255,230,120,.08));
      color:#fff4c6;
    }
    button.danger{
      border-color: rgba(255,120,120,.30);
      background: linear-gradient(180deg, rgba(255,120,120,.22), rgba(255,120,120,.09));
    }
    button:active{ transform: translateY(1px); }

    .dpad{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .dpad button{
      min-width: unset;
      min-height: 52px;
      flex: unset;
    }
    .dpad .empty{
      opacity:0;
      pointer-events:none;
    }

    .label{
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
    }
    .sliderWrap{
      display:grid;
      gap: 6px;
    }
    input[type="range"]{
      width:100%;
    }
    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
    }
    .spacer{ flex: 1 1 auto; }

    /* Responsive: portrait iPad -> controls move to bottom */
    @media (max-width: 820px){
      .main{ flex-direction:column; }
      .panel{ flex: 0 0 auto; max-width: none; }
      .arena{ min-height: 56vh; }
      button{ min-width: 140px; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="贪吃蛇 2.0 全屏版">
    <header>
      <h1>贪吃蛇 2.0</h1>
      <div class="sub">iPad 全屏布局（非小窗口）<br>支持滑动 / 方向键 / 按钮</div>
    </header>

    <div class="main">
      <div class="arena">
        <canvas id="c" width="1200" height="780"></canvas>
      </div>

      <div class="panel" aria-label="控制面板">
        <div class="row">
          <span class="pill">分数 <span id="score">0</span></span>
          <span class="pill">长度 <span id="len">3</span></span>
          <span class="pill">速度 <span id="spd">0.6x</span></span>
        </div>

        <div class="row">
          <button id="startBtn" class="primary" type="button">开始</button>
          <button id="pauseBtn" type="button">暂停</button>
          <button id="resetBtn" class="danger" type="button">重置</button>
        </div>

        <div class="sliderWrap">
          <div class="row" style="justify-content:space-between;">
            <span class="label">速度调节（更慢也可以）</span>
            <span class="pill" id="speedPill">0.6x</span>
          </div>
          <!-- slower range: 0.2x to 2.5x -->
          <input id="speed" type="range" min="0.2" max="2.5" value="0.6" step="0.1" />
          <div class="hint">提示：把速度拉到 0.2x 会非常慢，适合练手。</div>
        </div>

        <div class="row">
          <button id="wrapBtn" type="button">穿墙：关</button>
          <button id="gridBtn" class="warn" type="button">网格：中</button>
        </div>

        <div class="dpad" aria-label="方向键">
          <button class="empty" aria-hidden="true"></button>
          <button id="upBtn" type="button">⬆</button>
          <button class="empty" aria-hidden="true"></button>
          <button id="leftBtn" type="button">⬅</button>
          <button id="downBtn" type="button">⬇</button>
          <button id="rightBtn" type="button">➡</button>
        </div>

        <div class="hint" id="hint">
          键盘：←/→/↑/↓ 控制方向；Space 暂停；R 重置。画布上滑动也可换方向。
        </div>

        <div class="spacer"></div>
        <div class="hint" style="opacity:.9;">
          建议用 Safari 打开后「添加到主屏幕」，体验更像 App。
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const $score = document.getElementById('score');
  const $len = document.getElementById('len');
  const $spd = document.getElementById('spd');
  const $speed = document.getElementById('speed');
  const $speedPill = document.getElementById('speedPill');
  const $hint = document.getElementById('hint');

  const state = {
    running: false,
    paused: false,
    wrap: false,
    speed: 0.6,         // default slower
    acc: 0,
    last: performance.now(),
    tile: 22,
    gridMode: 1,        // 0 off, 1 medium, 2 strong
  };

  const board = {
    cols: 34,
    rows: 20,
    x0: 0,
    y0: 0,
    w: 0,
    h: 0
  };

  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  let snake, dir, nextDir, food, score, grow, gameOver;

  function computeLayout(){
    // Fit grid to canvas with margins; prefer larger tiles for iPad
    const pad = 36;
    const usableW = canvas.width - pad*2;
    const usableH = canvas.height - pad*2;

    const tile = Math.floor(Math.min(usableW/board.cols, usableH/board.rows));
    // tile set by "网格" button: small/medium/large feel
    const base = clamp(tile, 16, 30);
    const t = (state.gridMode === 0) ? base : base; // tile same; gridMode affects line visibility only
    state.tile = t;

    board.w = state.tile * board.cols;
    board.h = state.tile * board.rows;
    board.x0 = Math.floor((canvas.width - board.w)/2);
    board.y0 = Math.floor((canvas.height - board.h)/2);
  }

  function fitCanvasToBox(){
    // Keep internal resolution proportional to displayed size for crispness
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.max(600, Math.floor(rect.width * dpr));
    const h = Math.max(420, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
      computeLayout();
      draw();
    }
  }

  function updateHud(){
    $score.textContent = String(score);
    $len.textContent = String(snake.length);
    $spd.textContent = state.speed.toFixed(1) + 'x';
    $speedPill.textContent = state.speed.toFixed(1) + 'x';
  }

  function placeFood(){
    const occupied = new Set(snake.map(p => p.x + ',' + p.y));
    let tries = 0;
    while (tries++ < 800){
      const fx = randInt(0, board.cols-1);
      const fy = randInt(0, board.rows-1);
      const key = fx + ',' + fy;
      if (!occupied.has(key)){
        food = {x:fx, y:fy};
        return;
      }
    }
    food = {x:0,y:0};
  }

  function init(){
    const cx = Math.floor(board.cols/2);
    const cy = Math.floor(board.rows/2);
    snake = [{x:cx-1,y:cy},{x:cx,y:cy},{x:cx+1,y:cy}];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    score = 0;
    grow = 0;
    gameOver = false;
    placeFood();
    updateHud();
    draw();
  }

  function setDir(nx, ny){
    if (nx === -dir.x && ny === -dir.y) return;
    nextDir = {x:nx, y:ny};
  }

  function step(){
    if (gameOver) return;

    dir = nextDir;

    const head = snake[snake.length-1];
    let nx = head.x + dir.x;
    let ny = head.y + dir.y;

    if (state.wrap){
      nx = (nx + board.cols) % board.cols;
      ny = (ny + board.rows) % board.rows;
    } else {
      if (nx < 0 || nx >= board.cols || ny < 0 || ny >= board.rows){
        gameOver = true;
        state.running = false;
        state.paused = false;
        $hint.textContent = '游戏结束：撞墙了。点“开始”重新开局，或点“重置”。';
        return;
      }
    }

    const tail = snake[0];
    const willGrow = (grow > 0);
    const occupied = new Set(snake.map(p => p.x + ',' + p.y));
    const key = nx + ',' + ny;
    const tailKey = tail.x + ',' + tail.y;
    const hitsBody = occupied.has(key) && !(key === tailKey && !willGrow);

    if (hitsBody){
      gameOver = true;
      state.running = false;
      state.paused = false;
      $hint.textContent = '游戏结束：咬到自己了。点“开始”重新开局，或点“重置”。';
      return;
    }

    snake.push({x:nx,y:ny});

    if (nx === food.x && ny === food.y){
      score += 10;
      grow += 2;
      placeFood();
    }

    if (grow > 0) grow -= 1;
    else snake.shift();

    updateHud();
  }

  function roundRect(ctx,x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function draw(){
    // background
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, 'rgba(255,255,255,0.03)');
    g.addColorStop(1, 'rgba(0,0,0,0.34)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // board background
    ctx.save();
    ctx.translate(board.x0, board.y0);

    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(0,0,board.w,board.h);

    // grid lines visibility based on gridMode
    const gridAlpha = (state.gridMode === 0) ? 0.0 : (state.gridMode === 1 ? 0.05 : 0.09);
    if (gridAlpha > 0){
      ctx.strokeStyle = `rgba(255,255,255,${gridAlpha})`;
      ctx.lineWidth = 1;
      for (let x=0;x<=board.cols;x++){
        ctx.beginPath();
        ctx.moveTo(x*state.tile + 0.5, 0);
        ctx.lineTo(x*state.tile + 0.5, board.h);
        ctx.stroke();
      }
      for (let y=0;y<=board.rows;y++){
        ctx.beginPath();
        ctx.moveTo(0, y*state.tile + 0.5);
        ctx.lineTo(board.w, y*state.tile + 0.5);
        ctx.stroke();
      }
    }

    // food (apple)
    const fx = food.x * state.tile;
    const fy = food.y * state.tile;
    ctx.save();
    ctx.translate(fx + state.tile/2, fy + state.tile/2);
    ctx.fillStyle = 'rgba(255,120,120,0.92)';
    ctx.beginPath();
    ctx.arc(0, 0, state.tile*0.36, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = 'rgba(110,255,170,0.75)';
    ctx.beginPath();
    ctx.ellipse(state.tile*0.12, -state.tile*0.30, state.tile*0.18, state.tile*0.10, -0.6, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // snake
    for (let i=0;i<snake.length;i++){
      const p = snake[i];
      const x = p.x * state.tile;
      const y = p.y * state.tile;

      const isHead = i === snake.length-1;
      const alpha = 0.92 - (snake.length-1-i) * 0.012;

      ctx.fillStyle = isHead ? 'rgba(200,235,255,0.96)' : `rgba(110,168,255,${clamp(alpha,0.38,0.88)})`;
      ctx.strokeStyle = 'rgba(255,255,255,0.14)';
      ctx.lineWidth = 2;

      const r = state.tile * 0.28;
      roundRect(ctx, x+2, y+2, state.tile-4, state.tile-4, r);
      ctx.fill();
      ctx.stroke();

      if (isHead){
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        const ex = x + state.tile/2 + dir.x*4;
        const ey = y + state.tile/2 + dir.y*4;
        ctx.beginPath(); ctx.arc(ex-5, ey-4, 2.3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(ex+5, ey-4, 2.3, 0, Math.PI*2); ctx.fill();
      }
    }

    // border
    ctx.strokeStyle = 'rgba(255,255,255,0.11)';
    ctx.lineWidth = 3;
    ctx.strokeRect(0,0,board.w,board.h);

    ctx.restore();

    // overlays
    if (!state.running){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.22)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'rgba(232,238,252,0.92)';
      ctx.font = '1000 30px system-ui,-apple-system,Segoe UI,Roboto,Arial';
      ctx.textAlign = 'center';
      ctx.fillText(gameOver ? '游戏结束' : '贪吃蛇 2.0', canvas.width/2, canvas.height/2 - 18);
      ctx.font = '800 14px system-ui,-apple-system,Segoe UI,Roboto,Arial';
      ctx.fillStyle = 'rgba(232,238,252,0.82)';
      const tip = gameOver ? '点“开始”重新开局；或点“重置”' : '点“开始”开局；滑动/方向键/按钮控制';
      ctx.fillText(tip, canvas.width/2, canvas.height/2 + 16);
      ctx.restore();
    } else if (state.paused){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.22)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'rgba(232,238,252,0.90)';
      ctx.font = '1000 26px system-ui,-apple-system,Segoe UI,Roboto,Arial';
      ctx.textAlign = 'center';
      ctx.fillText('暂停', canvas.width/2, canvas.height/2);
      ctx.restore();
    }
  }

  function loop(now){
    fitCanvasToBox();
    const dt = Math.min(0.06, (now - state.last)/1000);
    state.last = now;

    if (state.running && !state.paused){
      // Slower base step; and allow speed down to 0.2x (very slow)
      const base = 0.22;                 // seconds per step at 1.0x (slower than v1)
      const interval = base / Math.max(0.05, state.speed);

      state.acc += dt;
      while (state.acc >= interval){
        state.acc -= interval;
        step();
        if (!state.running) break;
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  // Controls
  function start(){
    gameOver = false;
    state.running = true;
    state.paused = false;
    state.acc = 0;
    $hint.textContent = '键盘：←/→/↑/↓ 控制方向；Space 暂停；R 重置。画布上滑动也可换方向。';
  }
  function pause(){
    if (!state.running) return;
    state.paused = !state.paused;
    document.getElementById('pauseBtn').textContent = state.paused ? '继续' : '暂停';
  }
  function reset(){
    init();
    state.running = false;
    state.paused = false;
    state.acc = 0;
    document.getElementById('pauseBtn').textContent = '暂停';
    $hint.textContent = '键盘：←/→/↑/↓ 控制方向；Space 暂停；R 重置。画布上滑动也可换方向。';
  }

  document.getElementById('startBtn').addEventListener('click', () => {
    init();
    start();
  });
  document.getElementById('pauseBtn').addEventListener('click', pause);
  document.getElementById('resetBtn').addEventListener('click', reset);

  document.getElementById('upBtn').addEventListener('click', () => setDir(0,-1));
  document.getElementById('downBtn').addEventListener('click', () => setDir(0,1));
  document.getElementById('leftBtn').addEventListener('click', () => setDir(-1,0));
  document.getElementById('rightBtn').addEventListener('click', () => setDir(1,0));

  document.getElementById('wrapBtn').addEventListener('click', () => {
    state.wrap = !state.wrap;
    document.getElementById('wrapBtn').textContent = state.wrap ? '穿墙：开' : '穿墙：关';
  });

  document.getElementById('gridBtn').addEventListener('click', () => {
    state.gridMode = (state.gridMode + 1) % 3; // 0/1/2
    document.getElementById('gridBtn').textContent =
      state.gridMode === 0 ? '网格：关' : (state.gridMode === 1 ? '网格：中' : '网格：强');
  });

  $speed.addEventListener('input', () => {
    state.speed = parseFloat($speed.value);
    updateHud();
  });

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp') setDir(0,-1);
    if (e.key === 'ArrowDown') setDir(0,1);
    if (e.key === 'ArrowLeft') setDir(-1,0);
    if (e.key === 'ArrowRight') setDir(1,0);
    if (e.key.toLowerCase() === 'r') reset();
    if (e.key === ' ') { pause(); e.preventDefault(); }
  });

  // Swipe on canvas
  let touch0 = null;
  canvas.addEventListener('pointerdown', (e) => {
    touch0 = {x: e.clientX, y: e.clientY};
    canvas.setPointerCapture?.(e.pointerId);
  });
  canvas.addEventListener('pointerup', (e) => {
    if (!touch0) return;
    const dx = e.clientX - touch0.x;
    const dy = e.clientY - touch0.y;
    touch0 = null;
    const ax = Math.abs(dx), ay = Math.abs(dy);
    if (Math.max(ax, ay) < 18) return;
    if (ax > ay) setDir(dx > 0 ? 1 : -1, 0);
    else setDir(0, dy > 0 ? 1 : -1);
  });

  // Init
  state.speed = parseFloat($speed.value);
  computeLayout();
  init();
  requestAnimationFrame(loop);

  // Handle orientation/resize
  window.addEventListener('resize', () => {
    state.acc = 0;
    fitCanvasToBox();
  });
})();
</script>
</body>
</html>
