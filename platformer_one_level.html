<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>平台跳跃小游戏（一关版）</title>
  <style>
    :root{
      --bg:#0b0f19;
      --border: rgba(255,255,255,.14);
      --text:#e8eefc;
      --muted: rgba(232,238,252,.72);
      --shadow: 0 14px 36px rgba(0,0,0,.40);
      --panel: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    }
    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      margin:0;
      background: radial-gradient(1100px 800px at 30% 10%, #1a2346 0%, var(--bg) 55%, #070a12 100%);
      color:var(--text);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;
      overflow:hidden;
    }

    /* More compact UI for 9.7" iPad */
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      padding:
        calc(10px + env(safe-area-inset-top))
        calc(10px + env(safe-area-inset-right))
        calc(10px + env(safe-area-inset-bottom))
        calc(10px + env(safe-area-inset-left));
      gap: 8px;
    }

    header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: var(--panel);
      box-shadow: var(--shadow);
      flex: 0 0 auto;
      min-height: 48px;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
    }
    h1{ margin:0; font-size:14px; font-weight: 1000; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .sub{ font-size:11px; color: var(--muted); line-height:1.35; }

    .right{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.16);
      color: rgba(232,238,252,.90);
      font-weight: 950;
      font-size: 12px;
      display:inline-flex;
      gap: 8px;
      align-items:center;
      white-space:nowrap;
    }

    .main{
      flex: 1 1 auto;
      display:flex;
      min-height: 0;
      gap: 8px;
    }

    .arena{
      flex: 1 1 auto;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.16);
      overflow:hidden;
      box-shadow: var(--shadow);
      min-width: 0;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }
    canvas{
      width: 100%;
      height: 100%;
      display:block;
      touch-action:none;
    }

    .panel{
      flex: 0 0 280px;
      max-width: 300px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-height: 0;
    }

    .row{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap:wrap;
    }
    button{
      padding: 11px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(18,26,43,.55);
      color: var(--text);
      font-weight: 1000;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      flex: 1 1 auto;
      min-width: 96px;
      font-size: 13px;
    }
    button.primary{
      border-color: rgba(110,168,255,.46);
      background: linear-gradient(180deg, rgba(110,168,255,.34), rgba(110,168,255,.12));
    }
    button.danger{
      border-color: rgba(255,120,120,.30);
      background: linear-gradient(180deg, rgba(255,120,120,.22), rgba(255,120,120,.09));
    }
    button.warn{
      border-color: rgba(255,230,120,.30);
      background: linear-gradient(180deg, rgba(255,230,120,.22), rgba(255,230,120,.08));
      color:#fff4c6;
    }
    button:active{ transform: translateY(1px); }

    .dpad{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:8px;
      align-items:stretch;
    }
    .dpad button{ min-width: unset; min-height: 48px; }
    .dpad .empty{ opacity:0; pointer-events:none; }

    .hint{
      font-size: 11px;
      color: var(--muted);
      line-height: 1.45;
    }
    .spacer{ flex: 1 1 auto; }

    /* Portrait / small width: controls go bottom */
    @media (max-width: 820px){
      .main{ flex-direction:column; }
      .panel{ flex: 0 0 auto; max-width: none; }
      .arena{ min-height: 54vh; }
      button{ min-width: 110px; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="平台跳跃小游戏（一关版）">
    <header>
      <div class="title">
        <h1>平台跳跃（蘑菇变大）</h1>
        <div class="sub">一关版：左右移动、跳跃、踩怪、吃蘑菇变大、到旗帜通关</div>
      </div>
      <div class="right">
        <span class="pill">分数 <span id="score">0</span></span>
        <span class="pill">生命 <span id="life">3</span></span>
        <span class="pill">状态 <span id="state">小</span></span>
      </div>
    </header>

    <div class="main">
      <div class="arena">
        <canvas id="c"></canvas>
      </div>

      <div class="panel" aria-label="控制面板">
        <div class="row">
          <button id="startBtn" class="primary" type="button">开始</button>
          <button id="pauseBtn" type="button">暂停</button>
          <button id="resetBtn" class="danger" type="button">重置</button>
        </div>

        <div class="dpad" aria-label="方向键">
          <button class="empty" aria-hidden="true"></button>
          <button id="jumpBtn" class="warn" type="button">跳</button>
          <button class="empty" aria-hidden="true"></button>
          <button id="leftBtn" type="button">⬅</button>
          <button id="downBtn" type="button">蹲</button>
          <button id="rightBtn" type="button">➡</button>
        </div>

        <div class="hint" id="hint">
          键盘：←/→ 或 A/D 移动；↑/W/Space 跳；S/↓ 蹲。<br>
          规则：踩到怪物能消灭；侧面撞到怪物会掉血（大→小，小→掉命）。吃蘑菇会变大。到旗帜通关。
        </div>

        <div class="spacer"></div>
        <div class="hint" style="opacity:.9;">
          提示：用 Safari 打开后「添加到主屏幕」，更像 App。
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const $score = document.getElementById('score');
  const $life  = document.getElementById('life');
  const $state = document.getElementById('state');
  const $hint  = document.getElementById('hint');

  const input = { left:false, right:false, jump:false, down:false };

  const game = {
    running: false,
    paused: false,
    time: 0,
    score: 0,
    lives: 3,
    big: false,
    invulnT: 0,
    win: false,
    over: false,
  };

  const world = {
    gravity: 2600,
    friction: 0.84,
    airFriction: 0.99,
    w: 4200,
    h: 900,
    groundY: 690,
  };

  const cam = { x:0, y:0 };

  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function aabb(a,b){
    return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);
  }

  function fitCanvas(){
    const r = canvas.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.max(560, Math.floor(r.width * dpr));
    const h = Math.max(360, Math.floor(r.height * dpr));
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
    }
  }

  const solids = [];
  const decorations = [];
  const enemies = [];
  const pickups = [];
  let flag = null;

  function rect(x,y,w,h, type='solid'){
    return {x,y,w,h,type};
  }

  function buildLevel(){
    solids.length = 0;
    decorations.length = 0;
    enemies.length = 0;
    pickups.length = 0;
    flag = null;

    // Ground segments + a pit
    solids.push(rect(0, world.groundY, 1480, world.h-world.groundY));
    solids.push(rect(1700, world.groundY, world.w-1700, world.h-world.groundY));

    // Platforms
    addPlatform(420, 560, 260, 26);
    addPlatform(860, 510, 220, 26);
    addPlatform(1220, 460, 220, 26);

    // Steps around pit
    addPlatform(1540, 610, 120, 26);
    addPlatform(1630, 540, 140, 26);

    // Pipes
    addPipe(2050, world.groundY-110, 90, 110);
    addPipe(2360, world.groundY-150, 90, 150);

    // Stairs
    addStairs(2700, world.groundY, 6, 42, 42);

    // High platform with mushroom
    addPlatform(3200, 520, 320, 26);
    pickups.push({x:3340,y:480,w:28,h:28,type:'mushroom', taken:false, vy:0, vx:40});

    // Enemies
    enemies.push(makeEnemy(980, world.groundY-34));
    enemies.push(makeEnemy(1420, world.groundY-34));
    enemies.push(makeEnemy(2140, world.groundY-34));
    enemies.push(makeEnemy(2860, world.groundY-34));
    enemies.push(makeEnemy(3450, 520-34));

    // Flag
    flag = { x: 3980, y: world.groundY-250, w: 26, h: 250 };
    decorations.push({type:'flag', x: flag.x+10, y: flag.y+22, w: 46, h: 22});
  }

  function addPlatform(x,y,w,h){
    solids.push(rect(x,y,w,h,'platform'));
    decorations.push({type:'brick', x,y,w,h});
  }
  function addPipe(x,y,w,h){
    solids.push(rect(x,y,w,h,'pipe'));
    decorations.push({type:'pipe', x,y,w,h});
  }
  function addStairs(xStart, groundY, steps, stepW, stepH){
    for (let i=0;i<steps;i++){
      const h = (i+1)*stepH;
      const x = xStart + i*stepW;
      const y = groundY - h;
      solids.push(rect(x,y,stepW,h,'stair'));
      decorations.push({type:'stair', x,y,w:stepW,h});
    }
  }
  function makeEnemy(x,y){
    return { x,y,w:32,h:32, vx: -80 + Math.random()*160, vy:0, alive:true, squishT:0 };
  }

  const player = {
    x: 140, y: world.groundY-44,
    w: 28, h: 44,
    vx: 0, vy: 0,
    onGround: false,
    facing: 1,
    crouch: false,
  };

  function playerSize(){
    if (game.big){
      player.w = 32;
      player.h = player.crouch ? 44 : 64;
    } else {
      player.w = 28;
      player.h = player.crouch ? 32 : 44;
    }
  }

  function updateHud(){
    $score.textContent = String(game.score);
    $life.textContent = String(game.lives);
    $state.textContent = game.big ? '大' : '小';
  }

  function setHintDefault(){
    $hint.innerHTML = '键盘：←/→ 或 A/D 移动；↑/W/Space 跳；S/↓ 蹲。<br>规则：踩到怪物能消灭；侧面撞到怪物会掉血（大→小，小→掉命）。吃蘑菇会变大。到旗帜通关。';
  }
  function flash(msg){
    $hint.textContent = msg;
    setTimeout(() => { if (!game.win && !game.over) setHintDefault(); }, 1100);
  }

  function resetAll(){
    game.running = false;
    game.paused = false;
    game.time = 0;
    game.score = 0;
    game.lives = 3;
    game.big = false;
    game.invulnT = 0;
    game.win = false;
    game.over = false;

    player.x = 140;
    player.y = world.groundY-44;
    player.vx = 0; player.vy = 0;
    player.onGround = false;
    player.facing = 1;
    player.crouch = false;

    buildLevel();
    updateHud();
    setHintDefault();
    document.getElementById('pauseBtn').textContent = '暂停';
  }

  function start(){
    if (game.over || game.win) resetAll();
    game.running = true;
    game.paused = false;
    document.getElementById('pauseBtn').textContent = '暂停';
    flash('开始！');
  }
  function pause(){
    if (!game.running) return;
    game.paused = !game.paused;
    document.getElementById('pauseBtn').textContent = game.paused ? '继续' : '暂停';
  }

  function step(dt){
    if (!game.running || game.paused || game.win || game.over) return;

    game.time += dt;
    game.invulnT = Math.max(0, game.invulnT - dt);

    player.crouch = !!input.down && player.onGround;
    playerSize();

    const accel = player.onGround ? 2400 : 1700;
    const maxV = player.onGround ? 330 : 300;

    if (input.left){ player.vx -= accel * dt; player.facing = -1; }
    if (input.right){ player.vx += accel * dt; player.facing = 1; }
    player.vx = clamp(player.vx, -maxV, maxV);

    if (input.jump && player.onGround && !player.crouch){
      player.vy = -780;
      player.onGround = false;
      input.jump = false;
    }

    player.vy += world.gravity * dt;

    if (player.onGround){
      if (!input.left && !input.right){
        player.vx *= Math.pow(world.friction, dt*60);
        if (Math.abs(player.vx) < 10) player.vx = 0;
      }
    } else {
      player.vx *= Math.pow(world.airFriction, dt*60);
    }

    moveAndCollide(player, dt);
    updatePickups(dt);
    updateEnemies(dt);

    if (flag && aabb(player, flag)){
      game.win = true;
      game.running = false;
      flash('通关！你到达旗帜！');
    }

    const viewW = canvas.width / (Math.min(2, window.devicePixelRatio||1));
    cam.x = clamp(player.x - (viewW*0.45), 0, world.w - viewW);
  }

  function moveAndCollide(obj, dt){
    obj.x += obj.vx * dt;
    for (const s of solids){
      if (!aabb(obj, s)) continue;
      if (obj.vx > 0){ obj.x = s.x - obj.w; obj.vx = 0; }
      else if (obj.vx < 0){ obj.x = s.x + s.w; obj.vx = 0; }
    }

    obj.y += obj.vy * dt;
    obj.onGround = false;
    for (const s of solids){
      if (!aabb(obj, s)) continue;
      if (obj.vy > 0){ obj.y = s.y - obj.h; obj.vy = 0; obj.onGround = true; }
      else if (obj.vy < 0){ obj.y = s.y + s.h; obj.vy = 0; }
    }

    if (obj.y > world.h + 200) loseLife('掉进坑里了');
  }

  function updatePickups(dt){
    for (const p of pickups){
      if (p.taken) continue;

      if (p.type === 'mushroom'){
        p.vy += world.gravity * dt;
        p.x += (p.vx || 0) * dt;
        p.y += p.vy * dt;

        for (const s of solids){
          if (!aabb(p,s)) continue;

          if (p.vy > 0){ p.y = s.y - p.h; p.vy = 0; }
          else if (p.vy < 0){ p.y = s.y + s.h; p.vy = 0; }

          if (p.x < s.x){ p.x = s.x - p.w; p.vx = -Math.abs(p.vx||40); }
          else if (p.x + p.w > s.x + s.w){ p.x = s.x + s.w; p.vx = Math.abs(p.vx||40); }
        }
      }

      if (aabb(player, p)){
        p.taken = true;
        if (p.type === 'mushroom'){
          if (!game.big){ game.big = true; game.score += 50; flash('吃到蘑菇：变大！'); }
          else { game.score += 20; flash('蘑菇：加分'); }
          updateHud();
        }
      }
    }
  }

  function updateEnemies(dt){
    for (const e of enemies){
      if (!e.alive){ e.squishT -= dt; continue; }

      e.vy += world.gravity * dt;
      e.x += e.vx * dt;

      for (const s of solids){
        if (!aabb(e,s)) continue;
        if (e.vx > 0){ e.x = s.x - e.w; e.vx *= -1; }
        else if (e.vx < 0){ e.x = s.x + s.w; e.vx *= -1; }
      }

      e.y += e.vy * dt;
      for (const s of solids){
        if (!aabb(e,s)) continue;
        if (e.vy > 0){ e.y = s.y - e.h; e.vy = 0; }
        else if (e.vy < 0){ e.y = s.y + s.h; e.vy = 0; }
      }

      if (aabb(player, e)){
        const playerBottomPrev = player.y + player.h - player.vy*dt;
        const stomping = (player.vy > 160) && (playerBottomPrev <= e.y + 8);
        if (stomping){
          e.alive = false;
          e.squishT = 0.7;
          game.score += 100;
          player.vy = -520;
          updateHud();
          flash('踩怪成功 +100');
        } else {
          if (game.invulnT <= 0) hurt();
        }
      }
    }
  }

  function hurt(){
    game.invulnT = 1.1;
    if (game.big){
      game.big = false;
      player.crouch = false;
      playerSize();
      flash('被撞到：变小！');
    } else {
      loseLife('被怪物撞到');
    }
    updateHud();
  }

  function loseLife(reason){
    game.lives -= 1;
    updateHud();
    if (game.lives <= 0){
      game.over = true;
      game.running = false;
      $hint.textContent = '游戏结束：' + reason + '。点“开始”重开。';
      return;
    }
    flash('掉命：' + reason + '（剩余 ' + game.lives + '）');
    game.big = false;
    game.invulnT = 1.2;
    player.x = 140;
    player.y = world.groundY - 44;
    player.vx = 0; player.vy = 0;
    player.onGround = false;
    cam.x = 0;
  }

  function draw(){
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, 'rgba(120,180,255,0.10)');
    g.addColorStop(0.55, 'rgba(0,0,0,0.12)');
    g.addColorStop(1, 'rgba(0,0,0,0.34)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawStars();

    ctx.save();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    ctx.translate(-cam.x*dpr, 0);

    // ground fill
    ctx.fillStyle = 'rgba(8, 14, 26, 0.55)';
    ctx.fillRect(0, world.groundY*dpr, world.w*dpr, (world.h-world.groundY)*dpr);

    for (const s of solids){
      if (s.h > 160 && s.y === world.groundY) continue;
      drawSolid(s, dpr);
    }
    for (const d of decorations) drawDeco(d, dpr);
    for (const p of pickups){ if (!p.taken) drawMushroom(p, dpr); }
    for (const e of enemies) drawEnemy(e, dpr);
    if (flag) drawFlag(flag, dpr);
    drawPlayer(dpr);

    ctx.restore();

    if (!game.running && !game.paused){
      if (game.win) overlay('通关！', '点“开始”再来一局');
      else if (game.over) overlay('游戏结束', '点“开始”重开');
      else overlay('准备好了吗？', '点“开始”开局');
    } else if (game.paused){
      overlay('暂停', '点“继续”或按 Space');
    }
  }

  function overlay(title, subtitle){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(232,238,252,0.92)';
    ctx.font = '1000 34px system-ui,-apple-system,Segoe UI,Roboto,Arial';
    ctx.fillText(title, canvas.width/2, canvas.height/2 - 16);
    ctx.font = '800 14px system-ui,-apple-system,Segoe UI,Roboto,Arial';
    ctx.fillStyle = 'rgba(232,238,252,0.82)';
    ctx.fillText(subtitle, canvas.width/2, canvas.height/2 + 16);
    ctx.restore();
  }

  function drawStars(){
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.07)';
    const n = 70;
    for (let i=0;i<n;i++){
      const x = (i*173) % canvas.width;
      const y = (i*89) % canvas.height;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawSolid(s, dpr){
    ctx.save();
    const x = s.x*dpr, y = s.y*dpr, w = s.w*dpr, h = s.h*dpr;
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 2*dpr;
    roundRect(x, y, w, h, 10*dpr);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawDeco(d, dpr){
    const x = d.x*dpr, y = d.y*dpr, w = d.w*dpr, h = d.h*dpr;
    if (d.type === 'brick'){
      ctx.save();
      ctx.fillStyle = 'rgba(110,168,255,0.10)';
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 2*dpr;
      roundRect(x, y, w, h, 10*dpr);
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1*dpr;
      const rowH = 14*dpr;
      for (let yy=y+rowH; yy<y+h; yy+=rowH){
        ctx.beginPath(); ctx.moveTo(x+6*dpr, yy); ctx.lineTo(x+w-6*dpr, yy); ctx.stroke();
      }
      const colW = 26*dpr;
      for (let xx=x+colW; xx<x+w; xx+=colW){
        ctx.beginPath(); ctx.moveTo(xx, y+6*dpr); ctx.lineTo(xx, y+h-6*dpr); ctx.stroke();
      }
      ctx.restore();
    } else if (d.type === 'pipe'){
      ctx.save();
      ctx.fillStyle = 'rgba(110,255,170,0.10)';
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 2*dpr;
      roundRect(x, y, w, h, 12*dpr);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = 'rgba(110,255,170,0.14)';
      roundRect(x-6*dpr, y-10*dpr, w+12*dpr, 18*dpr, 10*dpr);
      ctx.fill(); ctx.stroke();
      ctx.restore();
    } else if (d.type === 'stair'){
      ctx.save();
      ctx.fillStyle = 'rgba(255,230,120,0.08)';
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.lineWidth = 2*dpr;
      roundRect(x, y, w, h, 8*dpr);
      ctx.fill(); ctx.stroke();
      ctx.restore();
    }
  }

  function drawMushroom(p, dpr){
    ctx.save();
    const x = p.x*dpr, y = p.y*dpr;
    const size = p.w*dpr;

    ctx.fillStyle = 'rgba(255,120,120,0.92)';
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 2*dpr;
    roundRect(x, y, size, size*0.70, 10*dpr);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = 'rgba(232,238,252,0.78)';
    for (let i=0;i<4;i++){
      const dx = (i%2)*0.42 + 0.18;
      const dy = (i<2)*0.22 + 0.18;
      ctx.beginPath();
      ctx.arc(x + size*dx, y + size*dy, size*0.10, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = 'rgba(255,255,255,0.16)';
    roundRect(x + size*0.20, y + size*0.58, size*0.60, size*0.40, 10*dpr);
    ctx.fill();
    ctx.restore();
  }

  function drawEnemy(e, dpr){
    ctx.save();
    const x = e.x*dpr, y = e.y*dpr, w = e.w*dpr, h = e.h*dpr;

    if (!e.alive){
      ctx.globalAlpha = 0.65;
      ctx.fillStyle = 'rgba(255,200,200,0.30)';
      roundRect(x, y + h*0.62, w, h*0.38, 10*dpr);
      ctx.fill();
      ctx.restore();
      return;
    }

    ctx.fillStyle = 'rgba(255,200,200,0.18)';
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 2*dpr;
    roundRect(x, y, w, h, 12*dpr);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = 'rgba(0,0,0,0.30)';
    ctx.beginPath(); ctx.arc(x+w*0.35, y+h*0.38, 3*dpr, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+w*0.65, y+h*0.38, 3*dpr, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 3*dpr;
    ctx.beginPath();
    ctx.moveTo(x+w*0.25, y+h);
    ctx.lineTo(x+w*0.15, y+h+8*dpr);
    ctx.moveTo(x+w*0.75, y+h);
    ctx.lineTo(x+w*0.85, y+h+8*dpr);
    ctx.stroke();

    ctx.restore();
  }

  function drawFlag(f, dpr){
    ctx.save();
    const x = f.x*dpr, y = f.y*dpr, w = f.w*dpr, h = f.h*dpr;

    ctx.strokeStyle = 'rgba(232,238,252,0.50)';
    ctx.lineWidth = 5*dpr;
    ctx.beginPath();
    ctx.moveTo(x + w*0.5, y);
    ctx.lineTo(x + w*0.5, y + h);
    ctx.stroke();

    ctx.fillStyle = 'rgba(110,168,255,0.22)';
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 2*dpr;
    roundRect(x + w*0.5, y + 30*dpr, 62*dpr, 26*dpr, 8*dpr);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = 'rgba(255,255,255,0.10)';
    roundRect(x + w*0.5 - 18*dpr, y + h - 12*dpr, 36*dpr, 12*dpr, 8*dpr);
    ctx.fill();
    ctx.restore();
  }

  function drawPlayer(dpr){
    ctx.save();
    const x = player.x*dpr, y = player.y*dpr, w = player.w*dpr, h = player.h*dpr;

    if (game.invulnT > 0){
      const blink = Math.floor(game.invulnT*10) % 2 === 0;
      ctx.globalAlpha = blink ? 0.35 : 0.95;
    } else ctx.globalAlpha = 0.95;

    ctx.fillStyle = 'rgba(200,235,255,0.20)';
    ctx.strokeStyle = 'rgba(255,255,255,0.14)';
    ctx.lineWidth = 2*dpr;
    roundRect(x, y, w, h, 12*dpr);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = 'rgba(110,168,255,0.20)';
    roundRect(x + w*0.22, y + h*0.12, w*0.56, h*0.24, 10*dpr);
    ctx.fill();

    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    const fx = x + w*0.55 + player.facing*3*dpr;
    const fy = y + h*0.34;
    ctx.beginPath(); ctx.arc(fx - 4*dpr, fy, 2.3*dpr, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(fx + 4*dpr, fy, 2.3*dpr, 0, Math.PI*2); ctx.fill();

    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(0,0,0,0.20)';
    ctx.beginPath();
    ctx.ellipse(x+w*0.5, world.groundY*dpr + 14*dpr, (w*0.70), 10*dpr, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  let last = performance.now();
  function loop(now){
    fitCanvas();
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function bindHold(btn, onDown, onUp){
    btn.addEventListener('pointerdown', (e) => { onDown(); btn.setPointerCapture?.(e.pointerId); e.preventDefault(); });
    btn.addEventListener('pointerup',   (e) => { onUp(); e.preventDefault(); });
    btn.addEventListener('pointercancel', () => onUp());
    btn.addEventListener('touchstart', (e) => { onDown(); e.preventDefault(); }, {passive:false});
    btn.addEventListener('touchend',   (e) => { onUp(); e.preventDefault(); }, {passive:false});
  }

  bindHold(document.getElementById('leftBtn'),  () => input.left = true,  () => input.left = false);
  bindHold(document.getElementById('rightBtn'), () => input.right = true, () => input.right = false);
  bindHold(document.getElementById('downBtn'),  () => input.down = true,  () => input.down = false);

  document.getElementById('jumpBtn').addEventListener('click', () => { input.jump = true; });
  document.getElementById('startBtn').addEventListener('click', start);
  document.getElementById('pauseBtn').addEventListener('click', pause);
  document.getElementById('resetBtn').addEventListener('click', () => { resetAll(); });

  window.addEventListener('keydown', (e) => {
    const k = e.key;
    if (k === 'ArrowLeft' || k.toLowerCase() === 'a') input.left = true;
    if (k === 'ArrowRight' || k.toLowerCase() === 'd') input.right = true;
    if (k === 'ArrowDown' || k.toLowerCase() === 's') input.down = true;
    if (k === 'ArrowUp' || k.toLowerCase() === 'w' || k === ' ') { input.jump = true; if (k === ' ') e.preventDefault(); }
    if (k.toLowerCase() === 'r') resetAll();
    if (k.toLowerCase() === 'p') pause();
  });
  window.addEventListener('keyup', (e) => {
    const k = e.key;
    if (k === 'ArrowLeft' || k.toLowerCase() === 'a') input.left = false;
    if (k === 'ArrowRight' || k.toLowerCase() === 'd') input.right = false;
    if (k === 'ArrowDown' || k.toLowerCase() === 's') input.down = false;
  });

  let touch0 = null;
  canvas.addEventListener('pointerdown', (e) => {
    touch0 = {x: e.clientX, y: e.clientY};
    canvas.setPointerCapture?.(e.pointerId);
  });
  canvas.addEventListener('pointerup', (e) => {
    if (!touch0) return;
    const dx = e.clientX - touch0.x;
    const dy = e.clientY - touch0.y;
    touch0 = null;
    const ax = Math.abs(dx), ay = Math.abs(dy);
    if (Math.max(ax, ay) < 18) return;
    if (ax > ay){
      if (dx > 0){ input.right = true; setTimeout(() => input.right = false, 140); }
      else { input.left = true; setTimeout(() => input.left = false, 140); }
    } else {
      if (dy < 0) input.jump = true;
    }
  });

  resetAll();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
